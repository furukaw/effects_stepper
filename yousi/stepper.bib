@inproceedings{clements01,
  title = {Modeling an algebraic stepper},
  author = {Clements, John and Flatt, Matthew and Felleisen, Matthias},
  booktitle = {European symposium on programming},
  seriese = {ESOP '01},
  pages = {320--334},
  year = {2001},
  organization = {Springer}
}

@article{felleisen04,
  author = {Felleisen, Matthias and Findler, Robert Bruce and Flatt, Matthew and Krishnamurthi, Shriram},
  title = {The Structure and Interpretation of the Computer Science Curriculum},
  journal = {J. Funct. Program.},
  issue_date = {July 2004},
  volume = {14},
  number = {4},
  month = jul,
  year = {2004},
  issn = {0956-7968},
  pages = {365--378},
  numpages = {14},
  url = {http://dx.doi.org/10.1017/S0956796804005076},
 doi = {10.1017/S0956796804005076},
  acmid = {997813},
  publisher = {Cambridge University Press},
  address = {New York, NY, USA},
}

@book{felleisen09,
  title = {Semantics engineering with PLT Redex},
  author = {Felleisen, Matthias and Findler, Robert Bruce and Flatt, Matthew},
  year = {2009},
  publisher = {MIT Press}
}

@inproceedings{klein12,
  author = {Klein, Casey and Clements, John and Dimoulas, Christos and Eastlund, Carl and Felleisen, Matthias and Flatt, Matthew and McCarthy, Jay A. and Rafkind, Jon and Tobin-Hochstadt, Sam and Findler, Robert Bruce},
  title = {Run Your Research: On the Effectiveness of Lightweight Mechanization},
  booktitle = {Proceedings of the 39th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  series = {POPL '12},
  year = {2012},
  isbn = {978-1-4503-1083-3},
  location = {Philadelphia, PA, USA},
  pages = {285--296},
  numpages = {12},
  url = {http://doi.acm.org/10.1145/2103656.2103691},
  doi = {10.1145/2103656.2103691},
  acmid = {2103691},
  publisher = {ACM},
  address = {New York, NY, USA},
  keywords = {lightweight semantics engineering},
} 

@inproceedings{tsushima12,
  title = {An embedded type debugger},
  author = {Tsushima, Kanae and Asai, Kenichi},
  booktitle = {Symposium on Implementation and Application of Functional Languages},
  pages = {190--206},
  year = {2012},
  organization = {Springer}
}

@inproceedings{tunnell18,
  title = {Evaluating the Tracing of Recursion in the Substitution Notional Machine},
  author = {Tunnell Wilson, Preston and Fisler, Kathi and Krishnamurthi, Shriram},
  booktitle = {Proceedings of the 49th ACM Technical Symposium on Computer Science Education},
  series = {SIGCSE '18},
  pages = {1023--1028},
  year = {2018},
  organization = {ACM}
}

@inproceedings{FF1986,
  title = {Control operators, the SECD-machine, and the $\lambda$-calculus},  author = {Felleisen, Matthias and Friedman, Daniel P.},
  booktitle = {Formal Description of Programming Concepts III},
  editor = {Wirsing, M.},
  pages = {193--219},
  year = {1986},
  publisher = {Elsevier}
}

@inproceedings{DF1990,
  title = {Abstracting Control},
  author = {Danvy, Olivier and Filinski, Andrzej},
  booktitle = {Proceedings of the 1990 ACM Conference on Lisp and
	  Functional Programming},
  series = {LFP '90},
  pages = {151--160},
  year = {1990},
}

@article{NI2009,
author = {根岸純一 and 岩崎英哉},
title = {Haskellプログラムの開発を支援する{GHCi}デバッガフロントエンド},
journal = {情報処理学会論文誌プログラミング},
year = {2009},
volume = {2},
number = {3},
pages = {48--56},
month = jul,
}

@article{Bennett1973,
author = {C. H. Bennett},
title = {Logical Reversibility of Computation},
journal = {IBM Journal of Research and Development},
year = {1973},
volume = {17},
number = {6},
pages = {525--532},
month = nov,
}

@article{Cong16,
author = {Youyou Cong and Kenichi Asai},
title = {Implementing a stepper using delimited continuations},
journal = {7th International Symposium on Symbolic Computation in Software Science},
year = {2016},
volume = {39},
pages = {42--54},
}

@inproceedings{FCA18,
author = {Tsukino Furukawa and Youyou Cong and Kenichi Asai},
title = {Stepping {OCaml}},
booktitle = {Proceedings Sixth Workshop on Trends in Functional Programming in Education},
year = {submitted for publication},
note = {査読用に http://pllab.is.ocha.ac.jp/\~{}asai/tmp/paper.pdf から取得可能},
}

@Inproceedings{FCA19,
  author    = {Furukawa, Tsukino and Cong, Youyou and Asai, Kenichi},
  year      = {2019},
  title     = {Stepping {OCaml}},
  booktitle = {{\rm Proceedings Seventh International Workshop on}
               Trends in Functional Programming in Education,
               {\rm Chalmers University, Gothenburg, Sweden, 14th June 2018}},
  series    = {Electronic Proceedings in Theoretical Computer Science},
  volume    = {295},
  pages     = {17-34},
  doi       = {10.4204/EPTCS.295.2},
}

@book{Asai07,
author = {浅井健一},
title = {プログラミングの基礎},
publisher = {サイエンス社},
year = {2007},
month = feb,
}

@inproceedings{10.1145/2500365.2500590,
 author = {Kammar, Ohad and Lindley, Sam and Oury, Nicolas},
 title = {Handlers in Action},
 year = {2013},
 isbn = {9781450323260},
 publisher = {Association for Computing Machinery},
 address = {New York, NY, USA},
 url = {https://doi.org/10.1145/2500365.2500590},
 doi = {10.1145/2500365.2500590},
 booktitle = {Proceedings of the 18th ACM SIGPLAN International Conference on Functional Programming},
 pages = {145--158},
 numpages = {14},
 keywords = {haskell, modularity, monads, algebraic effects, continuations, effect handlers, effect typing},
 location = {Boston, Massachusetts, USA},
 series = {ICFP '13}
}

@InProceedings{10.1007/978-3-030-02768-1_22,
author="Hillerstr{\"o}m, Daniel
and Lindley, Sam",
editor="Ryu, Sukyoung",
title="Shallow Effect Handlers",
booktitle="Programming Languages and Systems",
year="2018",
publisher="Springer International Publishing",
address="Cham",
pages="415--435",
abstract="Plotkin and Pretnar's effect handlers offer a versatile abstraction for modular programming with user-defined effects. Traditional deep handlers are defined by folds over computation trees. In this paper we study shallow handlers, defined instead by case splits over computation trees. We show that deep and shallow handlers can simulate one another up to specific notions of administrative reduction. We present the first formal accounts of an abstract machine for shallow handlers and a Continuation Passing Style (CPS) translation for shallow handlers taking special care to avoid memory leaks. We provide implementations in the Links web programming language and empirically verify that neither implementation introduces unwarranted memory leaks.",
isbn="978-3-030-02768-1"
}

@inproceedings{e6cb0c3222794e48bf38cf44e46fe4aa,
title = "Continuation passing style for effect handlers",
abstract = "We present Continuation Passing Style (CPS) translations for Plotkin and Pretnar's effect handlers with Hillerstr{\"o}m and Lindley's row-typed fine-grain call-by-value calculus of effect handlers as the source language. CPS translations of handlers are interesting theoretically, to explain the semantics of handlers, and also offer a practical implementation technique that does not require special support in the target language's runtime.We begin with a first-order CPS translation into untyped lambda calculus which manages a stack of continuations and handlers as a curried sequence of arguments. We then refine the initial CPS translation first by uncurrying it to yield a properly tail-recursive translation and second by making it higher-order in order to contract administrative redexes at translation time. We prove that the higher-order CPS translation simulates effect handler reduction. We have implemented the higher-order CPS translation as a JavaScript backend for the Links programming language.",
keywords = "effect handlers, delimited control, continuation passing system, CPS, algebraic effects",
author = "Daniel Hillerstr{\"o}m and Sam Lindley and Robert Atkey and KC Sivaramakrishnan",
year = "2017",
month = "9",
day = "3",
doi = "10.4230/LIPIcs.FSCD.2017.18",
language = "English",
series = "Leibniz International Proceedings in Informatics (LIPIcs)",
pages = "18:1--18:19",
editor = "Dale Miller",
booktitle = "2nd International Conference on Formal Structures for Computation and Deduction (FSCD 2017)",
}

@article{10.1145/3158096,
author = {Biernacki, Dariusz and Pir\'{o}g, Maciej and Polesiuk, Piotr and Sieczkowski, Filip},
title = {Handle with Care: Relational Interpretation of Algebraic Effects and Handlers},
year = {2017},
issue_date = {December 2017},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {POPL},
url = {https://doi.org/10.1145/3158096},
doi = {10.1145/3158096},
journal = {Proc. ACM Program. Lang.},
month = dec,
articleno = {Article 8},
numpages = {30},
keywords = {row polymorphism, algebraic effect, logical relation}
}

@article{PRETNAR201519,
title = "An Introduction to Algebraic Effects and Handlers. Invited tutorial paper",
journal = "Electronic Notes in Theoretical Computer Science",
volume = "319",
pages = "19--35",
year = "2015",
note = "The 31st Conference on the Mathematical Foundations of Programming Semantics (MFPS XXXI).",
issn = "1571-0661",
doi = "https://doi.org/10.1016/j.entcs.2015.12.003",
url = "http://www.sciencedirect.com/science/article/pii/S1571066115000705",
author = "Matija Pretnar",
keywords = "algebraic effects, handlers, effect system, semantics, logic, tutorial",
abstract = "This paper is a tutorial on algebraic effects and handlers. In it, we explain what algebraic effects are, give ample examples to explain how handlers work, define an operational semantics and a type & effect system, show how one can reason about effects, and give pointers for further reading."
}

@comment{CPS変換}
@article{PLOTKIN1975125,
title = "Call-by-name, call-by-value and the λ-calculus",
journal = "Theoretical Computer Science",
volume = "1",
number = "2",
pages = "125--159",
year = "1975",
issn = "0304-3975",
doi = "https://doi.org/10.1016/0304-3975(75)90017-1",
url = "http://www.sciencedirect.com/science/article/pii/0304397575900171",
author = "G.D. Plotkin",
abstract = "This paper examines the old question of the relationship between ISWIM and the λ-calculus, using the distinction between call-by-value and call-by-name. It is held that the relationship should be mediated by a standardisation theorem. Since this leads to difficulties, a new λ-calculus is introduced whose standardisation theorem gives a good correspondence with ISWIM as given by the SECD machine, but without the letrec feature. Next a call-by-name variant of ISWIM is introduced which is in an analogous correspondence withthe usual λ-calculus. The relation between call-by-value and call-by-name is then studied by giving simulations of each language by the other and interpretations of each calculus in the other. These are obtained as another application of the continuation technique. Some emphasis is placed throughout on the notion of operational equality (or contextual equality). If terms can be proved equal in a calculus they are operationally equal in the corresponding language. Unfortunately, operational equality is not preserved by either of the simulations."
}

@comment{非関数化}
@Article{Reynolds1998,
author="Reynolds, John C.",
title="Definitional Interpreters for Higher-Order Programming Languages",
journal="Higher-Order and Symbolic Computation",
year="1998",
month="Dec",
day="01",
volume="11",
number="4",
pages="363--397",
abstract="Higher-order programming languages (i.e., languages in which procedures or labels can occur as values) are usually defined by interpreters that are themselves written in a programming language based on the lambda calculus (i.e., an applicative language such as pure LISP). Examples include McCarthy's definition of LISP, Landin's SECD machine, the Vienna definition of PL/I, Reynolds' definitions of GEDANKEN, and recent unpublished work by L. Morris and C. Wadsworth. Such definitions can be classified according to whether the interpreter contains higher-order functions, and whether the order of application (i.e., call by value versus call by name) in the defined language depends upon the order of application in the defining language. As an example, we consider the definition of a simple applicative programming language by means of an interpreter written in a similar language. Definitions in each of the above classifications are derived from one another by informal but constructive methods. The treatment of imperative features such as jumps and assignment is also discussed.",
issn="1573-0557",
doi="10.1023/A:1010027404223",
url="https://doi.org/10.1023/A:1010027404223"
}

@Inproceedings{EPTCS294.3,
  author    = {Whitington, John and Ridge, Tom},
  year      = {2019},
  title     = {Direct Interpretation of Functional Programs for Debugging},
  editor    = {Lindley, Sam and Scherer, Gabriel},
  booktitle = {{\rm Proceedings}
               ML Family  / OCaml Users and Developers workshops,
               {\rm Oxford, UK, 7th September 2017}},
  series    = {Electronic Proceedings in Theoretical Computer Science},
  volume    = {294},
  pages     = {41-73},
  doi       = {10.4204/EPTCS.294.3},
}
