\section{インタプリタの変換}
\label{section:transform}

本節では，CPS (継続渡し形式) を使って書かれた通常のインタプリタに、
正当性が証明されている (プログラムの動作を変えない)
非関数化 \cite{Reynolds1998} と CPS 変換 \cite{PLOTKIN1975125} という2種類のプログラム変換を施すことで，
コンテキストを明示的に保持するインタプリタを得て
そこからステッパを導出する方法について順に説明する．

\subsection{非関数化}
\label{subsection:defun}

非関数化は，高階関数を1階のデータ構造で表現する方法である．
この変換は機械的に行うことができる．

前節で書いたように，我々が定義したインタプリタは with handle 文の内部の実行を CPS を用いて実装している．
つまりそれぞれの with handle 文の内部を実行している間，その with handle 文までの限定継続を関数として引数に保持している．
その関数を非関数化することで，with handle 文までの継続を，内容の参照が可能なデータとして扱うことができるようになる．

\subsection{CPS変換}
\label{subsection:cps}

CPS 変換はプログラムの継続を引数として明示的に持つようにするプログラム変換であり，
これも機械的に行うことができる．

非関数化したインタプリタ関数を CPS 変換すると，インタプリタの実行全体のメタ継続関数を引数に持つようになる．
このメタ継続は入力プログラムでの with handle 文から外の継続に対応している．

\subsection{非関数化}
\label{subsection:defun2}

CPS 変換したことで引数に全体の継続を関数として持つようになったので，
これも非関数化すると，with handle から外の継続を表すデータを得ることができる．
1度目の非関数化で with handle までの継続のデータも得ているので，
ここまでの変換で継続を明示的に保持しているインタプリタが導出できた．

\subsection{出力}
\label{subsection:output}

ここまでの変換によってコンテキストの情報が得られたので、
プログラム全体を再構成して出力することが可能になった．
プログラムの計算が進んで書き換わる部分で
書き換え前後のプログラムを出力するように変更すると
ステッパが実装できる．

\subsection{CPS インタプリタを基にしたステッパ}
\label{subsection:stepper}

\ref{subsection:output} 節でステッパが実装できたが，
機械的な変換を何度も施したことでステッパ関数は複雑になっており，
保守性に欠けるなど実用上の問題がある．
そこで，元の CPS インタプリタ関数内の対応する部分に
出力に必要なコンテキスト情報および出力命令を追加すると，
CPS インタプリタと同じ構造でコンテキスト情報のための引数を増やしたようなステッパ関数を得られる．

以上の変換によって，
CPS インタプリタからコンテキストを表せるデータ構造および再帰呼び出し時に渡すべきコンテキスト情報を導出し，
ステッパを実装することができた．
