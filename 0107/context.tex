\section{ステッパの実装におけるコンテキスト}
\label{section:context}

ステッパは簡約のたびに簡約前後のプログラムを出力するインタプリタである。例えばプログラム \texttt{((fun a -> a) ((fun b -> b) (fun c -> c)))} を入力した場合、以下のように出力したい。

\begin{quote}
\begin{verbatim}
((fun a -> a) ((fun b -> b) (fun c -> c)))
((fun a -> a) (fun c -> c))

((fun a -> a) (fun c -> c))
(fun c -> c)
\end{verbatim}
\end{quote}

ステッパはインタプリタにステップ出力機能が加わったものなので、通常のインタプリタ関数に書き加えることで実装できる。図 \ref{figure:lambda} に OCaml による型無し$\lambda$計算の定義とインタプリタの実装を示す。関数 \texttt{subst : e -> (string * v) list -> e} は代入関数であり、\texttt{subst e [(x, v)]} は式 \texttt{e} の中の全ての変数 \texttt{x} を値 \texttt{v} に置換した式を返す。

ステッパは small-step での実行過程を見せるものであるが、small-step でなく big-step のインタプリタを基にして作ることで、関数適用や配列に対する処理やループ等のひとまとまりの実行の開始と終了を検知して「その部分の最後のステップまで飛ばす」等の機能を作ることが容易になる\ref{FCA19}ため、big-step のインタプリタを利用している。

\begin{figure}
\begin{verbatim}
(* 値 *)
type v = Var of string      (* x *)
       | Fun of string * e  (* fun x -> e *)

(* 式 *)
type e = Val of v      (* 値 *)
       | App of e * e  (* e e *)

(* インタプリタ *)
let rec eval (exp : e) : v = match exp with
  | Val (v) -> v  (* 値ならそのまま返す *)
  | App (e1, e2) ->
    (let v2 = eval e2 in  (* 引数部分を実行 *)
     let v1 = eval e1 in  (* 関数部分を実行 *)
     let reduct = match v1 with
       | Fun (x, e) -> subst e [(x, v2)]  (* 代入 e[v2/x] *)
       | _ -> failwith "type error" in  (* 関数部分が関数でなければ型エラー *)
     eval reduct)  (* 代入後の式を実行 *)
\end{verbatim}
\caption{型無し$\lambda$計算とそのインタプリタ}
\label{figure:lambda}
\end{figure}

このインタプリタをステッパにするには、簡約をする際に簡約前後のプログラムを出力する機能を追加すればよい。
関数 \texttt{eval} は実行する式の部分式を再帰的に実行する。すると、再帰呼び出しされた \texttt{eval} の中では、引数に実行中の部分式の情報しか与えられていない。
しかしステッパが出力したいのは実行中の部分式ではなく式全体であり、コンテキストを含めた式全体を出力するためには、実行中の式の構文木の他にコンテキストの情報が必要である。

コンテキストの情報を得るために、Clements ら\cite{clements01} は Racket の continuation mark を使用してコンテキストフレームの情報を記録したが、本研究ではインタプリタ関数に明示的にコンテキスト情報のための引数を追加する。筆者らは以前\cite{FCA19}、実際にインタプリタに引数を追加することによってステッパを実装した。図\ref{figure:lambda}のインタプリタにその変更を施すと、図\ref{figure:lambda_stepper}のようになる。ここでは関数 \texttt{memo :\ e -> e -> c -> unit} は、簡約前の式、簡約後の式、コンテキスト情報の3つの引数をとり、コンテキスト情報を利用して簡約前後の式にそれぞれコンテキストを付加することで簡約前後の式全体を得て出力する。

\begin{figure}
\begin{verbatim}
(* コンテキスト *)
type c = CId             (* [.] *)
       | CApp2 of e * c  (* [e [.]] *)
       | CApp1 of v * c  (* [[.] v] *)

(* 出力しながら再帰的に実行 *)
let rec eval (exp : e) (c : c) : v = match exp with
  | Val (v) -> v
  | App (e1, e2) ->
    (let v2 = eval e2 (CApp2 (e1, c)) in  (* コンテキストを1層深くする *)
     let v1 = eval e1 (CApp1 (v2, c)) in  (* コンテキストを1層深くする *)
     let redex = App (Val v1, Val v2) in
     let reduct = match v1 with
       | Fun (x, e) -> subst e [(x, v2)]
       | _ -> failwith "type error" in
     memo redex reduct c;                 (* コンテキストを利用して式全体を出力 *)
     eval reduct c)

(* 実行を始める *)
let stepper (exp : e) = eval exp CId
\end{verbatim}
\caption{型無し$\lambda$計算に対するステッパ}
\label{figure:lambda_stepper}
\end{figure}

図\ref{figure:lambda_stepper}のように、コンテキストを表すデータ型を定義して再帰呼び出し時の構造に合わせて引数として渡すようにすれば、式全体を再構成して出力することが可能になる。以前の研究 \cite{FCA19} ではこの方法を用いて try-with 構文を含む言語のステッパを実装することに成功した。
しかし、try-with のような制御構文を含む言語では、コンテキストを区切ってある区間のコンテキストを一度に捨てるなどの操作が必要になるため、コンテキストの構造が一次元的でなくなり、複雑なデータ構造の定義が必要になる可能性がある \cite{FCA19} 。

ところが、図\ref{figure:lambda_stepper}の\texttt{c}型の定義を見ると、各コンストラクタはインタプリタ関数の「どの再帰呼び出しか」に対応している。コンテキストの型は評価順序によって定まるものであり、評価順序はインタプリタ関数で定義されているので、コンテキストを表すデータ型の定義はインタプリタ関数から導出できるものであると考えられる。次節以降ではその導出方法の1つを提案する。
