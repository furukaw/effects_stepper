\section{インタプリタの変換}
\label{section:transform}

本節では、\ref{section:definition}節で定義したインタプリタ
(図\ref{figure:1cps})に対して、正当性の保証された２種類のプログラム変
換（非関数化と CPS 変換）をかけることで、コンテキストを明示的に保持する
インタプリタを得て、そこからステッパを作成する方法を示す。

%本節では、\ref{section:definition}節で定義したインタプリタ(図\ref{figure:1cps})を変換することで、コンテキストの情報を保持するインタプリタを得る方法を示す。用いるプログラム変換は非関数化とCPS変換の２種類である。これらの変換はプログラムの動作を変えないので、変換の結果得られるインタプリタと図\ref{figure:1cps}のインタプリタは、同じ引数 \texttt{e} に対して同じ値を返す。

\subsection{非関数化}
\label{section:2defun}

\ref{section:context}節で示したインタプリタは直接形式だったので、コン
テキスト情報を得るのに CPS 変換をかけてから非関数化をかけたが、
\ref{section:definition}節で示したインタプリタはオペレーション呼び出しをサ
ポートするため最初から CPS で書かれている。
したがって、ここではまず非関数化をかける。

非関数化というのは、高階関数を１階のデータ構造で表現する方法である。高
階関数は全てその自由変数を引数に持つような１階のデータ構造となり、高階
関数を呼び出していた部分は apply 関数の呼び出しとなる。この apply 関数
は、高階関数が呼び出されていたら行ったであろう処理を行うように別途、定
義されるものである。この変換は機械的に行うことができる。

具体的に図\ref{figure:1cps}のプログラムの継続 \texttt{k} 型の$\lambda$式を
非関数化するには次のようにする。
結果は図 \ref{figure:k_2defun}と図 \ref{figure:2defun}のようになる。

%まず、図\ref{figure:1cps}のプログラムの \texttt{k} 型の$\lambda$式を非関数化する。非関数化は以下の手順によって行われる。
\begin{enumerate}
\item 継続を表す$\lambda$式をコンストラクタに置き換える。その際、$\lambda$式内の自由変数はコンストラクタの引数にする。
その結果、得られるデータ構造は図 \ref{figure:k_2defun}のようになる。
図 \ref{figure:1cps}の中には、コメントとしてどの関数がどのコンストラク
タに置き換わったのかが書かれている。
\item 関数を表すコンストラクタと引数を受け取って中身を実行するような apply 関数を定義する。
これは、図 \ref{figure:2defun}では \texttt{apply\_in} と呼ばれている。
\item $\lambda$式を呼び出す部分を、apply 関数にコンストラクタと引数を渡すように変更する。
\end{enumerate}

%図\ref{figure:1cps}のインタプリタの \texttt{k} 型すなわち \texttt{v -> a} 型の$\lambda$式を非関数化すると、型 \texttt{k} の定義は図 \ref{figure:k_2defun} のようにヴァリアント型になり、インタプリタは図\ref{figure:2defun}に書き換わる。

\begin{figure}
\begin{verbatim}
and k = FId                 (* [.] *)
      | FApp2 of e * k      (* [e [.]] *)
      | FApp1 of v * k      (* [[.] v] *)
      | FOp of string * k   (* [op [.]] *)
      | FCall of k * h * k  (* [with h handle [[.]]] *)
\end{verbatim}
\caption{非関数化後の継続の型}
\label{figure:k_2defun}
\end{figure}

\begin{figure}
\begin{verbatim}
(* CPS インタプリタを非関数化した関数 *)
let rec eval (exp : e) (k : k) : a = match exp with
  | Val (v) -> apply_in k v  (* 継続適用関数に継続と値を渡す *)
  | App (e1, e2) -> eval e2 (FApp2 (e1, k))
  | Op (name, e) -> eval e (FOp (name, k))
  | With (h, e) ->
    let a = eval e FId in  (* 空の継続を渡す *)
    apply_handler k h a  (* handle 節内の実行結果をハンドラで処理 *)

(* handle 節内の継続を適用する関数 *)
and apply_in (k : k) (v : v) : a = match k with
  | FId -> Return v  (* 空の継続、そのまま値を返す *)
  | FApp2 (e1, k) -> let v2 = v in
    eval e1 (FApp1 (v2, k))
  | FApp1 (v2, k) -> let v1 = v in
    (match v1 with
     | Fun (x, e) ->
       let reduct = subst e [(x, v2)] in
       eval reduct k
     | Cont (k') ->
       apply_in (k' k) v2
     | _ -> failwith "type error")
  | FOp (name, k) -> OpCall (name, v, k)  (* この handle 節の実行結果は OpCall *)
  | FCall (k'', h, k') ->  (* k''[with h handle k'[v]] *)
    let a = apply_in k' v in  (* handle 節までの継続を適用 *)
    apply_handler k'' h a  (* a をハンドラ h で処理して、その後 k'' を適用 *)

(* handle 節内の実行結果をハンドラで処理する関数 *)
and apply_handler (k : k) (h : h) (a : a) : a = match a with
  | Return v ->
    (match h with {return = (x, e)} ->
       let reduct = subst e [(x, v)] in
       eval reduct k)
  | OpCall (name, v, k') ->
    (match search_op name h with
     | None -> OpCall (name, v, FCall (k, h, k'))
     | Some (x, y, e) ->
       let cont_value = Cont (fun k -> FCall (k, h, k')) in
       let reduct = subst e [(x, v); (y, cont_value)] in
       eval reduct k)

(* 初期継続を渡して実行を始める *)
let stepper (e : e) : a = eval e FId
\end{verbatim}
\caption{CPS インタプリタを非関数化したプログラム}
\label{figure:2defun}
\end{figure}

非関数化したインタプリタを見るといくつかのことがわかる。
まず、図 \ref{figure:k_2defun}を見ると、ラムダ計算の通常の評価文脈に加
えてオペレーション呼び出しの引数を実行するフレーム \texttt{FOp} と
捕捉された継続が呼び出されたときのフレーム \texttt{FCall}

（書き途中。ここで、この時点で得られたものをまとめるとともに、ステッパ
にするには何が足りていないかを書きたい。そして、それを、さらに CPS 変
換して非関数化する動機にしたい。）

（手を加えたのはここまで。この先の実装が定まらないと書き進められない感
じ。）

%非関数化したことで継続 \texttt{k} がコンストラクタとして表されるようになったので、継続の構造を参照することや、継続を部分的に書き換えることが可能になった。
%具体的な \texttt{k} の構造の例を示す。図 \ref{figure:2defun} の関数 \texttt{stepper} に入力プログラム \texttt{((fun a -> a) (with handler \{return x -> x, a(x; k) -> x\} handle ((fun b -> b) (a (fun c -> c))) (fun d -> d)))} を表す構文木を渡して実行を始めた場合、\texttt{(a (fun c -> c))} を関数 \texttt{eval} に渡して実行を始める際の継続は \texttt{FApp2 (Fun ("b", Var "b"), FApp1 (Fun ("d", Var "d")))} である。これは式 \texttt{(a (fun c -> c))} のコンテキスト \texttt{((fun a -> a) (with handler \{return x -> x, a(x; k) -> x\} handle ((fun b -> b) [.]) (fun d -> d)))} のうち、\texttt{handle} の内側に対応している。\texttt{handle} から外側が継続に含まれないのは、関数 \texttt{eval} で \texttt{with h handle e} の \texttt{e} の実行の再帰呼び出し時に初期継続を表す \texttt{FId} を渡しているためである。コンテキスト全体に対応した継続を得るために、この後の変換をさらに施す。

\subsection{CPS 変換}
\label{subsection:3cps}

図\ref{figure:2defun} では、末尾再帰でない再帰呼び出しの際に継続が初期化されてしまうせいでコンテキスト全体に対応する情報が継続に含まれなかったので、全ての継続を引数に持つようにするため、さらに CPS 変換を施す。この変換によって現れる継続は \texttt{a -> a} 型である。この型 \texttt{a -> a} の名前を \texttt{k2} とする。
変換したプログラムが図 \ref{figure:3cps} である。

\begin{figure}
\begin{verbatim}
(* CPS インタプリタを非関数化して CPS 変換した関数 *)
let rec eval (exp : e) (k : k) (k2 : k2) : a = match exp with
  | Val (v) -> apply_in k v k2
  | App (e1, e2) -> eval e2 (FApp2 (e1, k)) k2
  | Op (name, e) -> eval e (FOp (name, k)) k2
  | With (h, e) ->
    eval e FId (fun a -> apply_handler k h a k2) (* GHandle に変換される関数 *)

(* handle 節内の継続を適用する関数 *)
and apply_in (k : k) (v : v) (k2 : k2) : a = match k with
  | FId -> k2 (Return v)  (* handle 節の外の継続を適用 *)
  | FApp2 (e1, k) -> let v2 = v in
    eval e1 (FApp1 (v2, k)) k2
  | FApp1 (v2, k) -> let v1 = v in
    (match v1 with
     | Fun (x, e) ->
       let reduct = subst e [(x, v2)] in
       eval reduct k k2
     | Cont (k') ->
       apply_in (k' k) v2 k2
     | _ -> failwith "type error")
  | FOp (name, k) -> k2 (OpCall (name, v, k))
  | FCall (k'', h, k') ->
    apply_in k' v (fun a -> apply_handler k'' h a k2) (* GHandle に変換される関数 *)

(* handle 節内の実行結果をハンドラで処理する関数 *)
and apply_handler (k : k) (h : h) (a : a) (k2 : k2) : a = match a with
  | Return v ->
    (match h with {return = (x, e)} ->
       let reduct = subst e [(x, v)] in
       eval reduct k k2)
  | OpCall (name, v, k') ->
    (match search_op name h with
     | None ->
       k2 (OpCall (name, v, FCall (k, h, k'))) (* 外の継続を適用 *)
     | Some (x, y, e) ->
       let cont_value = Cont (fun k -> FCall (k, h, k')) in
       let reduct = subst e [(x, v); (y, cont_value)] in
       eval reduct k k2)

(* 初期継続を渡して実行を始める *)
let stepper (e : e) : a = eval e FId (fun a -> a)  (* GId に変換される関数 *)
\end{verbatim}
\caption{CPS インタプリタを非関数化して CPS 変換したプログラム}
\label{figure:3cps}
\end{figure}

\subsection{非関数化}
\label{subsection:4defun}

CPS 変換したことにより新たに現れた \texttt{a -> a} 型の匿名関数を非関数化する。非関数化によって型 \texttt{k2} の定義は図 \ref{figure:k2_4defun} に、ステッパ関数は図 \ref{figure:4defun} に変換される。

\begin{figure}
\begin{verbatim}
type k2 = GId
        | GHandle of k * h * k2
\end{verbatim}
\caption{2回目の非関数化後の継続の型}
\label{figure:k2_4defun}
\end{figure}

\begin{figure}
\begin{verbatim}
(* CPS インタプリタを非関数化して CPS 変換して非関数化した関数 *)
let rec eval (exp : e) (k : k) (k2 : k2) : a = match exp with
  | Val (v) -> apply_in k v k2
  | App (e1, e2) -> eval e2 (FApp2 (e1, k)) k2
  | Op (name, e) -> eval e (FOp (name, k)) k2
  | With (h, e) -> eval e FId (GHandle (k, h, k2))

(* handle 節内の継続を適用する関数 *)
and apply_in (k : k) (v : v) (k2 : k2) : a = match k with
  | FId -> apply_out k2 (Return v)
  | FApp2 (e1, k) -> let v2 = v in
    eval e1 (FApp1 (v2, k)) k2
  | FApp1 (v2, k) -> let v1 = v in
    (match v1 with
     | Fun (x, e) ->
       let reduct = subst e [(x, v2)] in
       eval reduct k k2
     | Cont (k') ->
       apply_in (k' k) v2 k2
     | _ -> failwith "type error")
  | FOp (name, k) -> apply_out k2 (OpCall (name, v, k))
  | FCall (k_last, h, k') -> apply_in k' v (GHandle (k_last, h, k2))

(* 全体の継続を適用する関数 *)
and apply_out (k2 : k2) (a : a) : a = match k2 with
  | GId -> a
  | GHandle (k, h, k2) -> apply_handler k h a k2

(* handle 節内の実行結果をハンドラで処理する関数 *)
and apply_handler (k_last : k) (h : h) (a : a) (k2 : k2) : a = match a with
  | Return v -> (match h with {return = (x, e)} ->
       let reduct = subst e [(x, v)] in
       eval reduct k_last k2)
  | OpCall (name, v, k') -> (match search_op name h with
     | None -> apply_out k2 (OpCall (name, v, FCall (k_last, h, k')))
     | Some (x, k, e) ->
       let cont_value = Cont (fun k_last -> FCall (k_last, h, k')) in
       let reduct = subst e [(x, v); (k, cont_value)] in
       eval reduct k_last k2)

(* 初期継続を渡して実行を始める *)
let stepper (e : e) : a = eval e FId GId
\end{verbatim}
\caption{CPS インタプリタを非関数化して CPS 変換して非関数化したプログラム}
\label{figure:4defun}
\end{figure}

この非関数化によって、引数 \texttt{k} と引数 \texttt{k2} からコンテキスト全体の情報が得られるようになった。
\ref{subsection:2defun} 節で示した例について比較する。\texttt{stepper} に入力プログラム \texttt{((fun a -> a) (with handler \{return x -> x, a(x; k) -> x\} handle ((fun b -> b) (a (fun c -> c))) (fun d -> d)))} を表す構文木を渡して実行を始めた場合、\texttt{(a (fun c -> c))} を表す構文木を関数 \texttt{eval} に渡して実行を始める際の継続 \texttt{k} は \ref{subsection:2defun} 節と同様に \texttt{{FApp2 (Fun ("b", Var "b"), FApp1 (Fun ("d", Var "d")))}} である。そして継続 \texttt{k2} は \texttt{GHandle ()}
具体的な \texttt{k} の構造の例を示す。図 \ref{figure:2defun} の関数 \texttt{stepper} に入力プログラム \texttt{((fun a -> a) (with handler \{return x -> x, a(x; k) -> x\} handle ((fun b -> b) (a (fun c -> c))) (fun d -> d)))} を表す構文木を渡して実行を始めた場合、\texttt{(a (fun c -> c))} を関数 \texttt{eval} に渡して実行を始める際の継続は \texttt{FApp2 (Fun ("b", Var "b"), FApp1 (Fun ("d", Var "d")))} である。これは式 \texttt{(a (fun c -> c))} のコンテキスト \texttt{((fun a -> a) (with handler \{return x -> x, a(x; k) -> x\} handle ((fun b -> b) [.]) (fun d -> d)))} のうち、\texttt{handle} の内側に対応している。\texttt{handle} から外側が継続に含まれないのは、関数 \texttt{eval} で \texttt{with h handle e} の \texttt{e} の実行の再帰呼び出し時に初期継続を表す \texttt{FId} を渡しているためである。コンテキスト全体に対応した継続を得るために、この後の変換をさらに施す。

\subsection{出力}
\label{subsection:memo}

\ref{subsection:4defun} 節までの変換によって、コンテキストの情報を引数に保持するインタプリタ関数を得ることができた。この情報を用いて簡約前後のプログラムを出力するように、図\ref{figure:4defun} のインタプリタの簡約が起こる部分に副作用を足すとステッパが得られる。図\ref{figure:5memo} が副作用を足した後の関数 \texttt{apply\_in} と \texttt{apply\_handler} であり、他の関数は簡約している部分が無いので図 \ref{figure:4defun} と変わらない。

\begin{figure}
\begin{verbatim}
(* handle 節内の継続を適用する関数 *)
and apply_in (k : k) (v : v) (k2 : k2) : a = match k with
  | FId -> apply_out k2 (Return v)
  | FApp2 (e1, k) -> let v2 = v in
    eval e1 (FApp1 (v2, k)) k2
  | FApp1 (v2, k) -> let v1 = v in
    (match v1 with
     | Fun (x, e) ->
       let redex = App (Val v1, Val v2) in  (* (fun x -> e) v2 *)
       let reduct = subst e [(x, v2)] in    (* e[v2/x] *)
       memo redex reduct (k, k2);
       eval reduct k k2
     | Cont (x, k') ->
       let redex = App (Val v1, Val v2) in               (* k' v2 *)
       let reduct = plug_in_handle (Val v2) (k' FId) in  (* k'[v2] *)
       memo redex reduct (k, k2);
       apply_in (k' k) v2 k2
     | _ -> failwith "type error")
  | FOp (name, k) -> apply_out k2 (OpCall (name, v, k))
  | FCall (k_last, h, k') ->
    apply_in k' v (GHandle (k_last, h, k2))

(* handle 節内の実行結果をハンドラで処理する関数 *)
and apply_handler (k : k) (h : h) (a : a) (k2 : k2) : a = match a with
  | Return v ->
    (match h with {return = (x, e)} ->
       let redex = With (h, Val v) in (* with handler{return x -> e} handle v *)
       let reduct = (subst e [(x, v)]) in  (* e[v/x] *)
       memo redex reduct (k, k2);
       eval reduct k k2)
  | OpCall (name, v, k') ->
    (match search_op name h with
     | None -> apply_out k2 (OpCall (name, v, FCall (k, h, k')))
     | Some (x, y, e) ->
       let redex = (* with handler {name(x; y) -> e} handle k'[(name v)] *)
         With (h, plug_in_handle (Op (name, Val v)) k') in
       let new_var = gen_var_name () in
       let cont_value =
         Cont (new_var, fun k -> FCall (k, h, k')) in
       let reduct = (* e[v/x, k[with h handle k']/y] *)
         subst e [(x, v); (y, cont_value)] in
       memo redex reduct (k, k2);
       eval reduct k k2)
\end{verbatim}
\caption{変換の後、出力関数を足して得られるステッパ}
\label{figure:5memo}
\end{figure}

ステップ表示では継続値の内容も見えるようにしたいので、継続を文字列で表す必要がある。ここでは継続を関数 \texttt{fun x -> e} のように \texttt{fun x => e} と表すこととする。すると各継続が仮引数名を持つ必要があるので構文木に追加する（図\ref{figure:v_5memo}）。新しい継続値を作る時に、プログラム中で使われていない変数名を生成する関数 \texttt{gen\_var\_name} を利用して仮引数を定めている。

\begin{figure}
\begin{verbatim}
type v = Var of string
       | Fun of string * e
       | Cont of e * (k -> k)
\end{verbatim}
\caption{継続を文字列で表すために変更した値の型}
\label{figure:v_5memo}
\end{figure}

関数 \texttt{memo :\ e -> e -> (k * k2) -> unit} は、簡約基とその簡約後の式と簡約時のコンテキストを受け取って、簡約前のプログラムと簡約後のプログラムをそれぞれ再構成して出力する。

図\ref{figure:5memo}で\texttt{memo}の引数に渡している \texttt{redex} および \texttt{reduct} は、以下に示すこの言語の small-step の実行規則の簡約前後の式に対応する。

\[
\begin{array}{c}
  (\texttt{h} = \texttt{handler \{return x -> e0, op1(x; k) -> e1, ..., opn(x; k) -> en\}}) \\
  \ \\
  \infer[(\textsf{AppFun})]
        {\Eval{(fun x -> e) v}{e[v/x]}}
        {}
        \qquad
        \infer[(\textsf{AppCont})]
              {\Eval{(fun x => F[x]) v}{F[v]}}
              {}  \\
              \ \\
              \infer[(\textsf{Return})]
                    {\Eval{with h handle v}{e0[v/x]}}
                    {}
                    \qquad
                    \infer[(\textsf{?})]
                          {\Eval{with h handle e}{e0[v/x]}}
                          {？} \\
\end{array}
\]
