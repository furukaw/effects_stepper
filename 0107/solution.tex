\section{生じる問題と解決方法}
\label{生じる問題と解決方法}

著者らの incremental でないステッパ\cite{FSA18}と同じようにステップ出力を行うと、incremental なステッパでは様々な問題が起きた。本節ではその問題と、回避するために行った出力内容の変更について説明する。

\subsection{情報の消失}
\label{生じる問題と解決方法-情報の消失}
\subsubsection{問題点}
\label{生じる問題と解決方法-情報の消失-問題点}
\ref{ステッパの動作-DrRacketのステッパ} 節および \ref{ステッパの動作-incrementalでないOCamlステッパ} 節で紹介した既存のステッパは、ステップ実行をした結果を蓄えておき、ユーザが表示ステップを切り替える際にその中から表示するステップの情報を検索して表示するので、ステップ番号を指定すれば任意のステップをすぐに表示することができる。それに対して本研究で提案するステッパは、表示を切り替える命令が入力されるたびに１ステップ先や１ステップ前を計算することになる。その際のステッパの入力は前回出力したプログラムの一部である。すると、１ステップ前を計算する時に問題が起きる。

例えば、\texttt{2 * 3 + 5 * 7} というプログラムをステップ実行するとき、最初に表示される１ステップ目は\texttt{2 * 3 + 5 * 7 $\leadsto$ 2 * 3 + 35}であり、次ステップ表示命令が入力されると今度は \texttt{2 * 3 + 35} を入力として \texttt{2 * 3 + 35 $\leadsto$ 6 + 35} を出力する。ここで前ステップ表示命令が入力された時に、 \texttt{2 * 3 + 35} や \texttt{6 + 35} という情報から \texttt{2 * 3 + 5 * 7 $\leadsto$ 2 * 3 + 35} を導き出すことは不可能である。これは計算が不可逆的であるという性質によるものである。すなわち式 \texttt{5 * 7} と \texttt{35} のどちらからもその値が \texttt{35} だという情報は得られるが、式 \texttt{35} からそれがかつて \texttt{5 * 7} だったという情報は得られないのである。

\subsubsection{解決方法}
\label{生じる問題と解決方法-情報の消失-解決方法}

本研究の incremental なステッパでは、簡約後の式に簡約前の式の情報を、簡約された式を表す attribute \texttt{[@stepper.reduct ]} の引数として付加することで、簡約によって失われた情報を復元可能にする。「\texttt{式2} が簡約された結果の \texttt{式1}」を \texttt{式1[@stepper.reduct 式2]} と表して、\texttt{2 * 3 + 5 * 7 $\leadsto$ 2 * 3 + 35} の代わりに \texttt{2 * 3 + 5 * 7 $\leadsto$ 2 * 3 + 35[@stepper.reduct 5 * 7 ]}、また \texttt{2 * 3 + 35 $\leadsto$ 6 + 35} の代わりに \texttt{2 * 3 + 35[@stepper.reduct 5 * 7 ] $\leadsto$ 6[@stepper.reduct 2 * 3 ] + 35[@stepper.reduct 5 * 7 ]} を出力すると、どのステップの出力からでもオリジナルのプログラムまで情報を復元することができる。

さらに、直前のステップで簡約された式が明示的に分かるように、簡約された時のステップ番号も attribute に含める。例えば \texttt{6[@stepper.reduct 2 * 3 ] + 35[@stepper.reduct 5 * 7 ]} に \texttt{2 * 3} や \texttt{5 * 7} のそれぞれの簡約が行われた当時のステップ番号を追加して、\texttt{6[@stepper.reduct (2, 2 * 3) ] + 35[@stepper.reduct (1, 5 * 7) ]} と出力する。こうすると、ここから前のステップを求めるときに、最後に簡約されたのは \texttt{6} だとステップ番号から分かり、\texttt{6} をその attribute に記録された簡約前の式 \texttt{2 * 3} に置き換えることで前のステップ \texttt{2 * 3 + 35[@stepper.reduct (1, 5 * 7) ] $\leadsto$ 6[@stepper.reduct (2, 2 * 3) ] + 35[@stepper.reduct (1, 5 * 7) ]} が得られる。

\subsection{表示の崩れ}
\label{生じる問題と解決方法-表示の崩れ}
\subsubsection{問題点}
OCaml プログラムは、ライブラリで用意された関数を使うと文字列として出力することができ、本研究のステッパではその関数を利用する。その関数は、適当に改行やインデントを入れてプログラムを出力する。しかし、図\ref{figure:highlight} のように attribute が付いたプログラムを出力させて後から外部で attribute を消すと、プログラムの体裁が崩れてしまう可能性がある。

特に、\ref{生じる問題と解決方法-情報の消失-解決方法}節で示したように、簡約後の式に簡約前の式の情報を含む attribute を付けるようにしてステップ実行を進めると、attribute 付きの式の出力が複数行にわたってしまうことがある。すると、例えば
\begin{verbatim}
((2 * 3)
  [@reduct 長い式 ]) +
  (5 * 7)
\end{verbatim}
といった式の途中に改行が入った状態になり、外部のインタフェース用プログラムがこの文字列を受け取って
\begin{verbatim}
(2 * 3) + (5 * 7)
\end{verbatim}
と改行やスペースを調整して表示するのは難しい。

\subsubsection{解決方法}
\label{生じた問題と解決方法-表示の崩れ-解決方法}
我々は、実行に必要な情報がすべて含まれた式「処理用の式」と、表示するための整った式「表示用の式」をそれぞれ出力することでこれを解決した。

具体的には、\texttt{2 * 3 + 5 * 7} の最後のステップの出力が以下のようになるようにした。
\begin{verbatim}
  (* Step 2 *)
  [@@@stepper.process
    6[@stepper.reduct (2, 2 * 3) ] + 35[@stepper.reduct (1, 5 * 7) ] ]
  (6 + 35)[@x ]

  (* Step 3 *)
  [@@@stepper.process 41[@stepper.reduct (3,
    6[@stepper.reduct (2, 2 * 3) ] + 35[@stepper.reduct (1, 5 * 7) ] )] ]
  41[@t ]
\end{verbatim}
すなわち、
\begin{enumerate}
\item 処理用の簡約前の式（\texttt{[@stepper.reduct ]} を含む）を attribute に入れたもの
\item 表示用の簡約前の式（\texttt{[@x ]} を含む）
\item 処理用の簡約後の式（\texttt{[@stepper.reduct ]} を含む）を attribute に入れたもの
\item 表示用の簡約後の式（\texttt{[@t ]} を含む）
\end{enumerate}
の 4 つのプログラムを出力する。

「処理用の式」は前後のステップを計算するための情報を持つ式であり、そこまでの全ての簡約の情報を attribute に持つ。ユーザが見る画面には表示させないようにインタフェース側で処理をする。「表示用の式」はユーザに見せるための式であり、ハイライトをする式にのみ短い attribute が付いている。

余計な改行の原因である「簡約されている式をハイライトするための attribute」は、インタフェース側のプログラムが表示に利用するので完全に省略することはできない。そこで、上の例のように最も短い attribute \texttt{[@x ]}や \texttt{[@t ]} を簡約される式に付加することでハイライトする部分を示す。\texttt{x} と \texttt{t} はそれぞれ簡約基と簡約されたものを表す``redex''と``reduct''の略である。名前が 1 文字で他の情報を含まない attribute は文字数が少なくほとんどの場合改行を引き起こさないため、単純に attribute を文字列から削除してもユーザから見て不自然にプログラムの体裁が崩れることは少ないと考えられる。

次や前のステップを実行する際には、インタフェース側のプログラムが attribute である structure item \texttt{[@@@stepper.process ...]} の内容をステッパに渡すようにする。すると、ステッパには簡約の情報が全て含まれたプログラムが入力され、前のステップにも戻ることができる。前のステップの実行には処理用の簡約前の式、次のステップの実行には処理用の簡約後の式をステッパに渡す。
