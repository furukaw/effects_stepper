\section{予想される問題点}
本節では、本研究が提案するステッパを実際に利用するときに発生すると予想される問題点を挙げる。

\subsection{文字数の爆発}
本研究のステッパでは、任意のステップの「処理用の出力」に入力プログラムからそこまでの簡約の過程が記されているため、１ステップ進むごとに文字数が増加する。具体的には、簡約基 \texttt{e1} が式 \texttt{e2} に簡約されるステップでは、その時点のコンテキストを \texttt{E}、ステップ番号を \texttt{n} とすると、簡約前のプログラムが \texttt{E[e1]}、簡約後のプログラムが \texttt{E[e2[@stepper.reduct n;; e1]]} となる。\texttt{E} の文字数は変わらないので、\texttt{e2[@stepper.reduct n;;} と \texttt{]}の分の文字数が増加することになる。これを続けていくと、１ステップあたり少なくとも22文字は増加することになり、仮に百万ステップの簡約をするとプログラムは数千万文字になる。すると、毎ステップの入出力や通信に時間がかかる可能性がある。

解決策としては、古いステップの attribute は削除してしまうという方法が考えられる。たくさんのステップを見てから最初の方のステップまで戻るユーザは少ないと仮定すれば、ある程度前のステップについての attribute があったら、関数 \texttt{memo} で出力するプログラムを再構成する際に消去すれば、さほど実際の使用に影響なく出力する文字数を減らすことができる。

\subsection{実行時間}
\label{予想される問題点-実行時間}

ステップ数が膨大になると、後ろの方までステップ実行をするのは困難である。incremental なステッパでの実行速度は通常の OCaml 処理系に決して及ばないので、１ステップずつ進める場合でも、スキップ機能（\ref{実装-実際のステッパ}節）を使う場合でも、実行を多く進めるには長い時間が掛かってしまう。少しでも急ぐ為には、一般的なデバッガのように、ステップ実行したい式の付近にユーザがブレークポイントを設定して、そこからステップ実行を始めるという方法が考えられる。そのためには、ブレークポイントまでを部分的に native code にコンパイルして実行するなどの方法を取らざるを得ない。しかしいずれにしても、通常の OCaml コンパイラを用いても長時間かかるプログラムの実行を早く終わらせることは不可能である。

\subsection{関数適用評価スキップ後の前ステップ出力}

関数適用をスキップ（\ref{実装-実際のステッパ}節）した後に前のステップに戻ろうとすると、incremental でないステッパ\cite{FSA18}と同じように戻ることができない。たとえば図\ref{figure:skip}のように2の階乗の計算をスキップしたとすると、図\ref{figure:skip}の右の状態から、incremental でないステッパでは
\begin{itemize}
\item スキップをする前の関数適用式が簡約されるステップ5（図\ref{figure:skip}左）
\item 関数適用式が最終的な値になるステップ17（\texttt{3 * \colorbox{green}{(2 * 1)} $\leadsto$ 3 * \colorbox{purple}{2}}）
\end{itemize}
のどちらにも戻ることができたが、incremental なステッパでは前者にしか戻ることができない。

その原因は、incremental でないステッパ\cite{FSA18}では\ref{予想される問題点-実行時間}節で述べたように文字列検索によってステップ表示を切り替えていたので任意のステップに移ることができたのに対して、incremental なステッパでは関数適用式が値になるまでを１ステップとして出力し、その間の簡約についての情報は出力しないからである。

これを解決するには、スキップする部分の計算をしている間の簡約についても attribute に情報を蓄え、スキップ後のステップで全ての簡約の情報が入った長いプログラムを出力する必要がある。そのようにするとスキップにより時間がかかり\ref{予想される問題点-実行時間}節の問題がより深刻になる可能性があるので、2019年度に第二著者が受け持つ OCaml の初学者向けの授業で実際にステッパを使用し、実用の上で大きな問題になった場合に検討する。
